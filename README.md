# Неофициальный проект расширения иерархии в DefaultEcs
Проект дает возможность выстраивать иерархию сущностей по-умолчанию и по компонент-ключу.
Исопользуйте проект как идею для создания своей иерархии (уверен, профессионалы сделают лучше) или используйте nuget пакет.

# Как использовать:
1. Создаем мир и сущности.
2. Использует методы расширения SetParent статического класса EntityExtensions, для создания базовой иерархии.
3. Получаем ссылку на дерево, используя метод Trees.GetRoot(world) для получения базовой иерархии, либо Trees.GetOrCreate<TKey>(world) для получения иерархии по компонент-ключу.
4. Используем методы дерева для работы с иерархии: события, связанные с изменениями в иерархии, получение дочерних сущностей или для получения родителя для сущности.
5. По окончанию использования очищаем дерево Dispose(). Дерево очистится вместе с мета-компонентами, если ссылок на дерево больше нет.

# Приемущество
- Выстраивание иерархии начинается после создания дерева.
- Дерево связывает сущности через маркер HierarchyKey<TKey>, где TKey - компонент-ключ. Тип HierarchyKey<TKey> является публичным и вы в любой момент можете узнать ссылку на родительский TKey.
- Если дерево создано с помощью Trees.GetOrCreate<T, TKey>, где T - это обычный компонент, для которого нужна связка с TKey, а TKey - компонент-ключ, то все сущности с T компонентом будут иметь связь с родительским HierarchyKey<TKey>. Это дает возможность комбинировать типами в иерархии. Например, есть компонент Element, а есть ключ GroupElement. Все сущности с компонентом Element будут иметь маркер (HierarchyKey<GroupElement>) с ссылкой на ближайшую сущность с компонентом GroupElement. Так же отличным примером является Холст(TKey) и спрайты (T).
- Прекрасно работает с MultyMapSystem, так как сущности имеет одинаковый маркер (HierarchyKey<TKey>) и будут прекрасно группироваться. Используйте это преимущество для работы с иерархией в своих системах.
 
